<?xml version="1.0" encoding="UTF-8"?>
<files>
  <file path="_backend/build.rs">
    fn main()
  </file>
  <file path="_backend/src/commands.rs">
    use applydiff_core::{
        apply::Applier,
        backup,
        error::Result as PatchResult,
        logger::Logger,
        parse::Parser,
    };
    ---⋯
    use chrono::Local;
    ---⋯
    use serde::Serialize;
    ---⋯
    use similar::TextDiff;
    ---⋯
    use std::fs;
    ---⋯
    use std::path::PathBuf;
    ---⋯
    use tauri_plugin_dialog::{DialogExt, FilePath};
    ---⋯
    pub struct PreviewResult {
        pub log: String,
        pub diff: String,
    }
    ---⋯
    /* ========================== Commands ========================== */
    ---⋯
    pub async fn pick_folder(app: tauri::AppHandle) -&gt; Result&lt;String, String&gt;
    ---⋯
    pub fn get_ai_prompt() -&gt; String
    ---⋯
    pub fn run_self_test() -&gt; String
    ---⋯
    pub fn preview_patch(target: String, patch: String) -&gt; Result&lt;PreviewResult, String&gt;
    ---⋯
    pub fn apply_patch(target: String, patch: String) -&gt; Result&lt;String, String&gt;
    ---⋯
    /* ========================== Impl ========================== */
    ---⋯
    fn preview_patch_impl(target: &amp;str, patch: &amp;str) -&gt; PatchResult&lt;PreviewResult&gt;
    ---⋯
    use applydiff_core::error::{ErrorCode, PatchError};
    ---⋯
    // Harmonize EOLs
    ---⋯
    // Mirror append separator newline from apply logic
    ---⋯
    fn apply_patch_impl(target: &amp;str, patch: &amp;str) -&gt; PatchResult&lt;String&gt;
    ---⋯
    use applydiff_core::error::{ErrorCode, PatchError};
    ---⋯
    // Backup before applying
    ---⋯
    // Apply (partial success allowed)
    ---⋯
    fn generate_rid() -&gt; u64
  </file>
  <file path="_backend/src/main.rs">
    mod commands;
    ---⋯
    fn main()
  </file>
  <file path="app/app-state.js">
    /**
     * app-state.js
     * Global application state and event helpers.
     * No dependencies.
     */
    ---⋯
    // Initialize global state
    ---⋯
    // Event helper: emit custom event
    ---⋯
    // Event helper: listen to app event
  </file>
  <file path="app/console-panel.js">
    /**
     * console-panel.js
     * Manages console panel toggle and log display.
     */
    ---⋯
    function init()
    ---⋯
    // Listen for log events
    ---⋯
    (e) =&gt;
    ---⋯
    // Toggle console
    ---⋯
    // Clear console
    ---⋯
    () =&gt;
    ---⋯
    // Self-test button
    ---⋯
    () =&gt;
    ---⋯
    function toggleConsole()
    ---⋯
    function appendLog(message, level)
    ---⋯
    // Color by level or emoji prefix
    ---⋯
    // Auto-init
  </file>
  <file path="app/diff-panel.js">
    /**
     * diff-panel.js
     * Manages diff preview rendering and Apply button.
     */
    ---⋯
    function init()
    ---⋯
    // Listen for preview results
    ---⋯
    (e) =&gt;
    ---⋯
    // Apply button click
    ---⋯
    () =&gt;
    ---⋯
    function renderDiff(udiff)
    ---⋯
    line =&gt;
    ---⋯
    function updateApplyButton(hasDiff, hasError)
    ---⋯
    // Auto-init
  </file>
  <file path="app/patch-panel.js">
    /**
     * patch-panel.js
     * Manages patch input area, paste/type handling.
     */
    ---⋯
    function init()
    ---⋯
    // Enable patch area when directory selected
    ---⋯
    () =&gt;
    ---⋯
    // Clear editor after apply
    ---⋯
    () =&gt;
    ---⋯
    // Repopulate editor when version selected
    ---⋯
    (e) =&gt;
    ---⋯
    // Click to paste
    ---⋯
    // Header button handlers
    ---⋯
    () =&gt;
    ---⋯
    () =&gt;
    ---⋯
    async function handlePatchAreaClick()
    ---⋯
    // Try to read clipboard
    ---⋯
    // &lt;-- FIX 1: Set state on paste
    ---⋯
    // Fallback: typing mode
    ---⋯
    async function tryReadClipboard()
    ---⋯
    // Try Tauri clipboard first
    ---⋯
    // Silent fallback
    ---⋯
    // Try browser clipboard
    ---⋯
    // Silent fallback
    ---⋯
    function ensureEditor()
    ---⋯
    () =&gt;
    ---⋯
    () =&gt;
    ---⋯
    // &lt;-- FIX 2: Set state on type
    ---⋯
    function clearEditor()
    ---⋯
    // &lt;-- FIX 3: Clear state
    ---⋯
    // Auto-init
  </file>
  <file path="app/tauri-bridge.js">
    /**
     * tauri-bridge.js
     * All Tauri IPC calls. Listens for requests, emits results.
     * No direct DOM manipulation.
     */
    ---⋯
    // Tauri invoke wrapper
    ---⋯
    function invoke(...args)
    ---⋯
    // Pick folder
    ---⋯
    async () =&gt;
    ---⋯
    // Copy AI prompt
    ---⋯
    async () =&gt;
    ---⋯
    // Preview patch
    ---⋯
    async (e) =&gt;
    ---⋯
    // Apply patch
    ---⋯
    async (e) =&gt;
    ---⋯
    // Run self-test
    ---⋯
    async () =&gt;
  </file>
  <file path="app/ui-helpers.js">
    /**
     * ui-helpers.js
     * Shared UI utilities. No state, pure functions.
     * No dependencies.
     */
    ---⋯
    // Escape HTML for safe rendering
    ---⋯
    // Update status chip
    ---⋯
    // Emit log event
  </file>
  <file path="app/version-tabs.js">
    /**
     * version-tabs.js
     * Manages version history tabs and navigation.
     */
    ---⋯
    function init()
    ---⋯
    // Create v0 baseline when directory selected
    ---⋯
    (e) =&gt;
    ---⋯
    // Add new version when patch applied
    ---⋯
    (e) =&gt;
    ---⋯
    // Pagination
    ---⋯
    () =&gt;
    ---⋯
    () =&gt;
    ---⋯
    function renderTabs()
    ---⋯
    (v, i) =&gt;
    ---⋯
    () =&gt;
    ---⋯
    (e) =&gt;
    ---⋯
    function selectVersion(index)
    ---⋯
    // Emit event to repopulate patch panel
    ---⋯
    function extractFilesFromPatch(patch)
    ---⋯
    // dedupe
    ---⋯
    // Auto-init
  </file>
  <file path="core/src/apply.rs">
    use crate::error::{ErrorCode, PatchError, Result};
    ---⋯
    use crate::logger::Logger;
    ---⋯
    use crate::r#match::find_best_match;
    ---⋯
    use crate::parse::PatchBlock;
    ---⋯
    use std::fs;
    ---⋯
    use std::io::ErrorKind;
    ---⋯
    use std::path::{Component, PathBuf};
    ---⋯
    pub struct ApplyResult {
        pub matched_at: usize,
        pub matched_end: usize,
        pub score: f64,
    }
    ---⋯
    pub struct Applier&lt;'a&gt; {
        #[allow(dead_code)]
        logger: &amp;'a Logger,
        root: PathBuf,
        dry_run: bool,
    }
    ---⋯
    impl&lt;'a&gt; Applier&lt;'a&gt;
    ---⋯
    pub fn new(logger: &amp;'a Logger, root: PathBuf, dry_run: bool) -&gt; Self
    ---⋯
    pub fn apply_block(&amp;self, blk: &amp;PatchBlock) -&gt; Result&lt;ApplyResult&gt;
    ---⋯
    // harden: disallow absolute paths or '..' traversal
    ---⋯
    // read file, allow append-create if FROM is empty
    ---⋯
    // append/create when FROM is empty
    ---⋯
    // FIX: only insert a separator newline when appending to a NON-empty file that lacks one.
    ---⋯
    // find match (exact or fuzzy)
    ---⋯
    // harmonize EOL with matched slice
  </file>
  <file path="core/src/backup.rs">
    use crate::error::{ErrorCode, PatchError, Result};
    ---⋯
    use chrono::Local;
    ---⋯
    use std::fs;
    ---⋯
    use std::path::{Path, PathBuf};
    ---⋯
    pub fn create_backup(base: &amp;Path, files: &amp;[PathBuf]) -&gt; Result&lt;PathBuf&gt;
    ---⋯
    // UI feature for this is not currently connected
    ---⋯
    pub fn latest_backup(base: &amp;Path) -&gt; Option&lt;PathBuf&gt;
    ---⋯
    // UI feature for this is not currently connected
    ---⋯
    pub fn restore_backup(base: &amp;Path, backup_root: &amp;Path) -&gt; Result&lt;()&gt;
    ---⋯
    // Recursively copy files from backup_root back into base.
    ---⋯
    fn walk_copy(base: &amp;Path, root: &amp;Path, cur: &amp;Path) -&gt; Result&lt;()&gt;
  </file>
  <file path="core/src/error.rs">
    use std::path::PathBuf;
    ---⋯
    use thiserror::Error;
    ---⋯
    pub type Result&lt;T&gt; = std::result::Result&lt;T, PatchError&gt;;
    ---⋯
    pub enum ErrorCode {
        // Parse / matching
        ParseFailed,
        NoMatch,
    
        // File I/O
        FileReadFailed,
        FileWriteFailed,
    
        // Validation / bounds
        ValidationFailed,
        BoundsExceeded,
    }
    ---⋯
    // Parse / matching
    ---⋯
    // File I/O
    ---⋯
    // Validation / bounds
    ---⋯
    pub enum PatchError {
        #[error("{message} (context: {context})")]
        Validation { code: ErrorCode, message: String, context: String },
    
        #[error("{message} (file: {path:?})")]
        File { code: ErrorCode, message: String, path: PathBuf },
    
        #[error("{message} (context: {context})")]
        Parse { code: ErrorCode, message: String, context: String },
    
        #[error("{message} (file: {file:?})")]
        Apply { code: ErrorCode, message: String, file: PathBuf },
    }
  </file>
  <file path="core/src/lib.rs">
    pub mod apply;
    ---⋯
    pub mod backup;
    ---⋯
    pub mod error;
    ---⋯
    pub mod test_runner;
    ---⋯
    pub mod test_helpers;
    ---⋯
    pub mod logger;
    ---⋯
    pub mod r#match;
    ---⋯
    pub mod parse;
    ---⋯
    pub mod prompts;
  </file>
  <file path="core/src/logger.rs">
    use chrono::Utc;
    ---⋯
    use serde_json::json;
    ---⋯
    use std::cell::RefCell;
    ---⋯
    use std::rc::Rc;
    ---⋯
    pub struct Logger {
        rid: u64,
        // Optional buffer for capturing logs during tests
        output: Option&lt;Rc&lt;RefCell&lt;String&gt;&gt;&gt;,
    }
    ---⋯
    // Optional buffer for capturing logs during tests
    ---⋯
    impl Logger
    ---⋯
    /// Creates a new logger that prints to standard output.
    ---⋯
    pub fn new(rid: u64) -&gt; Self
    ---⋯
    /// Creates a new logger for testing that captures output to a string buffer.
    ---⋯
    pub fn new_for_test(rid: u64, buffer: Option&lt;Rc&lt;RefCell&lt;String&gt;&gt;&gt;) -&gt; Self
    ---⋯
    /// Structured JSONL info record (ts/level/rid/subsystem/action/msg).
    ---⋯
    pub fn info(&amp;self, subsystem: &amp;str, action: &amp;str, message: &amp;str)
    ---⋯
    fn emit(
            &amp;self,
            level: &amp;str,
            subsystem: &amp;str,
            action: &amp;str,
            code: Option&lt;u32&gt;,
            message: &amp;str,
        )
    ---⋯
    // If an output buffer is configured (for testing), write to it.
    ---⋯
    // Otherwise, print to standard output for live runs.
  </file>
  <file path="core/src/match/match_exact.rs">
    use crate::logger::Logger;
    ---⋯
    use super::MatchResult;
    ---⋯
    /// Fast path: check for a UNIQUE exact substring
    ---⋯
    pub fn try_exact_match(haystack: &amp;str, needle: &amp;str, logger: &amp;Logger) -&gt; Option&lt;MatchResult&gt;
  </file>
  <file path="core/src/match/match_fuzzy.rs">
    use crate::logger::Logger;
    ---⋯
    use super::{MatchResult, normalize_newlines, normalize_ws_preserve_newlines, normalize_relative_indent};
    ---⋯
    use strsim::normalized_damerau_levenshtein;
    ---⋯
    pub fn find_fuzzy_match(
        haystack: &amp;str,
        needle: &amp;str,
        ranges: &amp;[(usize, usize)],
        win_min: usize,
        win_max: usize,
        min_score: f64,
        logger: &amp;Logger,
    ) -&gt; Option&lt;MatchResult&gt;
    ---⋯
    // 1) Whitespace-normalized equality
    ---⋯
    // 2) Relative-indentation-normalized equality
    ---⋯
    // 3) Fuzzy match with Damerau-Levenshtein
    ---⋯
    // Trim trailing newline from slice
    ---⋯
    // CRLF-insensitive scoring
    ---⋯
    // Decide based on threshold and ambiguity
    ---⋯
    // Avoid wrong-place edits when two windows are nearly equal
    ---⋯
    fn scan_windows_equal(
        ranges: &amp;[(usize, usize)],
        haystack: &amp;str,
        needle_xfm: &amp;str,
        win_min: usize,
        win_max: usize,
        mut xfm: impl FnMut(&amp;str) -&gt; String,
    ) -&gt; Vec&lt;(usize, usize)&gt;
  </file>
  <file path="core/src/match/match_normalize.rs">
    /// Return a vector of (start_byte, end_byte) for each logical line,
    ---⋯
    /// where end includes the newline if present.
    ---⋯
    pub fn line_ranges(s: &amp;str) -&gt; Vec&lt;(usize, usize)&gt;
    ---⋯
    // Last line without trailing newline
    ---⋯
    /// Replace CRLF with LF for comparison/scoring
    ---⋯
    pub fn normalize_newlines(s: &amp;str) -&gt; String
    ---⋯
    /// Collapse horizontal whitespace runs to single space per line,
    ---⋯
    /// strip trailing whitespace. Newlines are preserved.
    ---⋯
    pub fn normalize_ws_preserve_newlines(s: &amp;str) -&gt; String
    ---⋯
    // Trim trailing single space
    ---⋯
    /// Remove uniform leading indentation (min leading spaces/tabs across non-empty lines)
    ---⋯
    pub fn normalize_relative_indent(s: &amp;str) -&gt; String
    ---⋯
    // Compute min leading whitespace
    ---⋯
    // Strip exactly `take` leading whitespace chars
  </file>
  <file path="core/src/match/mod.rs">
    use crate::logger::Logger;
    ---⋯
    mod match_exact;
    ---⋯
    mod match_fuzzy;
    ---⋯
    mod match_normalize;
    ---⋯
    pub use match_exact::try_exact_match;
    ---⋯
    pub use match_fuzzy::find_fuzzy_match;
    ---⋯
    pub use match_normalize::{normalize_newlines, normalize_ws_preserve_newlines, normalize_relative_indent};
    ---⋯
    /// Result of locating the best match of `needle` within `haystack`
    ---⋯
    pub struct MatchResult {
        pub start: usize,
        pub end: usize,
        pub score: f64,
    }
    ---⋯
    /// Top-level matching strategy (layered):
    ---⋯
    /// 1) Exact substring
    ---⋯
    /// 2) Whitespace-normalized equality
    ---⋯
    /// 3) Relative-indentation-normalized equality
    ---⋯
    /// 4) Fuzzy window search with ambiguity guard
    ---⋯
    pub fn find_best_match(
        haystack: &amp;str,
        needle: &amp;str,
        min_score: f64,
        logger: &amp;Logger,
    ) -&gt; Option&lt;MatchResult&gt;
    ---⋯
    // Fast path: exact match
    ---⋯
    // Prepare line ranges
    ---⋯
    // Calculate window sizes
    ---⋯
    // Try fuzzy matching
    ---⋯
    fn line_ranges(s: &amp;str) -&gt; Vec&lt;(usize, usize)&gt;
    ---⋯
    fn count_lines(s: &amp;str) -&gt; usize
  </file>
  <file path="core/src/parse/mod.rs">
    use crate::error::{ErrorCode, PatchError, Result};
    ---⋯
    use std::path::PathBuf;
    ---⋯
    mod parse_classic;
    ---⋯
    mod parse_armored;
    ---⋯
    mod parse_base64;
    ---⋯
    pub use parse_classic::parse_classic_block;
    ---⋯
    pub use parse_armored::parse_armored_block;
    ---⋯
    pub use parse_base64::decode_base64_lossy;
    ---⋯
    pub struct PatchBlock {
        pub file: PathBuf,
        pub from: String,
        pub to: String,
        pub fuzz: f64,
    }
    ---⋯
    pub struct Parser;
    ---⋯
    impl Parser
    ---⋯
    pub fn new() -&gt; Self
    ---⋯
    pub fn parse(&amp;self, input: &amp;str) -&gt; Result&lt;Vec&lt;PatchBlock&gt;&gt;
  </file>
  <file path="core/src/parse/parse_armored.rs">
    use crate::error::{ErrorCode, PatchError, Result};
    ---⋯
    use crate::parse::{PatchBlock, decode_base64_lossy};
    ---⋯
    use std::path::PathBuf;
    ---⋯
    pub fn parse_armored_block(
        lines: &amp;mut std::iter::Peekable&lt;std::iter::Enumerate&lt;std::str::Lines&lt;'_&gt;&gt;&gt;
    ) -&gt; Result&lt;PatchBlock&gt;
    ---⋯
    // Consume BEGIN line
    ---⋯
    // Read headers until "From:"
    ---⋯
    // Expect From:
    ---⋯
    // Collect base64 until 'To:'
    ---⋯
    // Collect base64 until END
  </file>
  <file path="core/src/parse/parse_base64.rs">
    /// Minimal base64 decoder that ignores ASCII whitespace. Returns raw bytes.
    ---⋯
    /// This avoids adding external dependencies to the core crate.
    ---⋯
    pub fn decode_base64_lossy(s: &amp;str) -&gt; Vec&lt;u8&gt;
    ---⋯
    // Mapping table: 255 = invalid, 254 = padding '='
    ---⋯
    // Collect values, ignoring whitespace
    ---⋯
    // Ignore invalid bytes
  </file>
  <file path="core/src/parse/parse_classic.rs">
    use crate::error::{ErrorCode, PatchError, Result};
    ---⋯
    use crate::parse::PatchBlock;
    ---⋯
    use regex::Regex;
    ---⋯
    use std::path::PathBuf;
    ---⋯
    pub fn parse_classic_block(
        lines: &amp;mut std::iter::Peekable&lt;std::iter::Enumerate&lt;std::str::Lines&lt;'_&gt;&gt;&gt;
    ) -&gt; Result&lt;PatchBlock&gt;
    ---⋯
    // Header
    ---⋯
    // Expect --- from
    ---⋯
    // Collect FROM until --- to
    ---⋯
    // Collect TO until &lt;&lt;&lt; (required)
    ---⋯
    // Trim trailing newline
  </file>
  <file path="core/src/prompts.rs">
    pub fn build_ai_prompt() -&gt; String
    ---⋯
    // Short, explicit instructions for LLMs to emit AFB-1 armored blocks.
    ---⋯
    // We keep this as a single string to avoid formatting surprises.
  </file>
  <file path="core/src/test_helpers.rs">
    use crate::error::{ErrorCode, PatchError, Result};
    ---⋯
    use chrono::Local;
    ---⋯
    use std::fs;
    ---⋯
    use std::path::{Path, PathBuf};
    ---⋯
    pub fn make_sandbox() -&gt; Result&lt;PathBuf&gt;
    ---⋯
    pub fn cleanup(dir: &amp;Path) -&gt; Result&lt;()&gt;
    ---⋯
    pub fn copy_dir_all(src: &amp;Path, dst: &amp;Path) -&gt; std::io::Result&lt;()&gt;
    ---⋯
    pub fn verify_dirs_match(
        log: &amp;mut String,
        actual_dir: &amp;Path,
        expected_dir: &amp;Path
    ) -&gt; std::result::Result&lt;(), String&gt;
    ---⋯
    // No 'after' dir means no verification needed
    ---⋯
    pub fn case_header(log: &amp;mut String, name: &amp;str)
    ---⋯
    pub fn logln&lt;S: Into&lt;String&gt;&gt;(buf: &amp;mut String, s: S)
  </file>
  <file path="core/src/test_runner.rs">
    use crate::apply::Applier;
    ---⋯
    use crate::logger::Logger;
    ---⋯
    use crate::parse::Parser;
    ---⋯
    use crate::test_helpers::*;
    ---⋯
    use chrono::Local;
    ---⋯
    use serde::Deserialize;
    ---⋯
    use std::cell::RefCell;
    ---⋯
    use std::fs;
    ---⋯
    use std::path::{Path, PathBuf};
    ---⋯
    use std::rc::Rc;
    ---⋯
    struct TestMeta {
        description: String,
        expect_ok: usize,
        expect_fail: usize,
        expected_log_contains: Option&lt;String&gt;,
    }
    ---⋯
    pub fn run() -&gt; String
    ---⋯
    fn run_test_case(rid: u64, log: &amp;mut String, case_path: &amp;Path) -&gt; bool
    ---⋯
    // Binary CRLF verification for crlf-related tests
    ---⋯
    /// Binary verification of line endings at byte level
    ---⋯
    fn verify_line_endings_binary(
        log: &amp;mut String,
        actual_path: &amp;Path,
        expected_crlf_count: usize,
        expected_solo_lf_count: usize,
        file_name: &amp;str,
    ) -&gt; std::result::Result&lt;(), String&gt;
    ---⋯
    // Count CRLF sequences (0x0D 0x0A)
    ---⋯
    // Count total LF (0x0A) including those in CRLF
    ---⋯
    // Solo LF = total LF minus those that are part of CRLF
    ---⋯
    // Verify expectations
    ---⋯
    /// Enhanced verification for CRLF test case
    ---⋯
    fn verify_crlf_preservation(
        log: &amp;mut String,
        sandbox: &amp;Path,
    ) -&gt; std::result::Result&lt;(), String&gt;
    ---⋯
    // Test 1: windows.txt - all CRLF (3 lines = 3 CRLF, 0 solo LF)
    ---⋯
    // Test 2: unix.txt - all LF (3 lines = 0 CRLF, 3 solo LF)
    ---⋯
    // Test 3: mixed.txt - 2 CRLF + 1 solo LF (3 total LF)
    ---⋯
    // Test 4: harmonize.txt - harmonization adopted CRLF from matched slice
    ---⋯
    fn find_tests_dir() -&gt; Option&lt;PathBuf&gt;
  </file>
  <file path="tests/07-ambiguity-indent/before/config.py">
    # First occurrence
    ---⋯
    def configure_alpha():
        # First occurrence
    ---⋯
    # Second occurrence (identical)
    ---⋯
    def configure_beta():
        # Second occurrence (identical)
  </file>
  <file path="tests/generate_large_files.rs">
    use std::fs;
    ---⋯
    use std::io::{BufWriter, Write};
    ---⋯
    use std::path::Path;
    ---⋯
    fn main()
    ---⋯
    // ---- Create the 'before' file ----
    ---⋯
    // The line we will target
    ---⋯
    // ---- Create the 'after' file ----
    ---⋯
    // The expected result after patching
  </file>
</files>
